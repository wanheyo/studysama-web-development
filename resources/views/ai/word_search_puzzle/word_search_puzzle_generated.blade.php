@extends('layout.master')
@section('title', 'AI Word Puzzle Generator')
@section('css')
<link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" rel="stylesheet">
@endsection
@section('main-content')
    <div class="container-fluid">
        <!-- Breadcrumb start -->
        <div class="row m-1">
            <div class="col-12">
                <h4 class="main-title">{{ $title ?? 'StudySama Word Puzzle' }}</h4>
                <ul class="app-line-breadcrumbs mb-3">
                    <li class="">
                        <a href="#" class="f-s-14 f-w-500">
                            <span>
                                <i class="ph-duotone ph-star-four f-s-16"></i> StudySama AI
                            </span>
                        </a>
                    </li>
                    <li class="">
                        <a href="{{ route('ai.word_search_puzzle') }}" class="f-s-14 f-w-500">
                            <span>Word Puzzle</span>
                        </a>
                    </li>
                    <li class="active">
                        <a href="#" class="f-s-14 f-w-500">Word Puzzle - {{ $title ?? 'StudySama Word Puzzle' }}</a>
                    </li>
                </ul>
            </div>
        </div>
        <!-- Breadcrumb end -->

        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">
                            <i class="ti ti-puzzle me-2"></i>{{ $title ?? 'StudySama Word Puzzle' }}
                        </h5>
                        <div class="d-flex align-items-center">
                            <div class="audio-controls me-3">
                                <button id="toggle-music" class="btn btn-sm btn-outline-secondary">
                                    <i class="ti ti-music me-1"></i><span id="music-text">Play Music</span>
                                </button>
                                <audio id="background-music" loop>
                                    <source src="{{ asset('assets/audio/study_background.mp3') }}" type="audio/mp3">
                                    Your browser does not support the audio element.
                                </audio>
                            </div>
                            <div class="quiz-timer">
                                <span class="badge bg-warning p-2">
                                    <i class="ti ti-clock me-1"></i>Time: <span id="minutes">00</span>:<span id="seconds">00</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        @if(session('error'))
                            <div class="alert alert-danger">
                                {{ session('error') }}
                            </div>
                        @endif

                        @if(!empty($words))
                            <div class="wsp-stats mb-4 d-flex justify-content-between">
                                <div class="progress w-100 mt-2">
                                    <div id="wsp-progress-bar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                                </div>
                                <span class="ms-3 badge bg-info p-2">
                                    <span id="current-word">0</span>/<span id="total-words">{{ count($words) }}</span>
                                </span>
                            </div>

                            <div class="puzzle-container">
                                <div class="row">
                                    <div class="col-md-8">
                                        <div class="puzzle-grid-container mb-4">
                                            <div class="puzzle-grid" id="puzzle-grid">
                                                <!-- Grid will be generated by JavaScript -->
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="word-list-container">
                                            <div class="card">
                                                <div class="card-header bg-primary text-white">
                                                    <h5 class="text-white mb-3">Words to Find <span id="found-count" class="badge bg-success">0</span>/<span id="total-words">{{ count($words) }}</span></h5>
                                                </div>
                                                <div class="card-body">
                                                    <ul class="list-group word-list" id="word-list">
                                                        @foreach($words as $word)
                                                            <li class="list-group-item d-flex justify-content-between align-items-center" data-word="{{ strtoupper($word) }}">
                                                                {{ $word }}
                                                                <span class="word-found-indicator">
                                                                    <i class="ti ti-search"></i>
                                                                </span>
                                                            </li>
                                                        @endforeach
                                                    </ul>
                                                </div>
                                            </div>
                                            <div class="mt-3">
                                                <button class="btn btn-warning w-100 mb-2" id="show-hint">
                                                    <i class="ti ti-bulb me-1"></i>Get a Hint
                                                </button>
                                                <button class="btn btn-danger w-100" id="give-up">
                                                    <i class="ti ti-flag me-1"></i>Give Up & Show Solution
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        @else
                            <div class="alert alert-info">
                                <p>No words were provided for the puzzle. Please try again with a different topic.</p>
                                <a href="{{ route('ai.word_search_puzzle') }}" class="btn btn-primary mt-3">
                                    <i class="ti ti-arrow-left me-1"></i>Go Back
                                </a>
                            </div>
                        @endif
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Results Modal -->
        <div class="modal fade" id="puzzleResultModal" tabindex="-1" aria-labelledby="puzzleResultModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header bg-primary">
                        <h5 class="modal-title text-white" id="puzzleResultModalLabel">Puzzle Complete!</h5>
                        <button aria-label="Close" class="btn-close m-0" data-bs-dismiss="modal" type="button"></button>
                    </div>
                    <div class="modal-body">
                        <div class="result-summary text-center mb-4">
                            <div class="celebration-animation mb-3">
                                <i class="ti ti-trophy text-warning" style="font-size: 64px;"></i>
                            </div>
                            <h3>Great Job!</h3>
                            <p>You've completed the word puzzle!</p>
                            <p>Time taken: <span id="time-taken">00:00</span></p>
                            <div class="mt-3">
                                <h4>Your Score: <span id="final-score" class="text-success">0</span></h4>
                                <p class="text-muted">Score is based on how quickly you completed the puzzle</p>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <a href="{{ route('ai.word_search_puzzle') }}" class="btn btn-secondary">
                            <i class="ti ti-home me-1"></i>Return Home
                        </a>
                        <button type="button" class="btn btn-primary" id="restart-puzzle">
                            <i class="ti ti-refresh me-1"></i>Try Again
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Keyboard Shortcut Modal -->
        <div class="modal fade" id="keyboardShortcutModal" tabindex="-1" aria-labelledby="keyboardShortcutModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="keyboardShortcutModalLabel">Keyboard Shortcuts</h5>
                        <button aria-label="Close" class="btn-close m-0" data-bs-dismiss="modal" type="button"></button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="col-12">
                                <div class="table-responsive">
                                    <table class="table table-bordered">
                                        <thead>
                                            <tr>
                                                <th>Key</th>
                                                <th>Action</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td><kbd>H</kbd></td>
                                                <td>Get a hint</td>
                                            </tr>
                                            <tr>
                                                <td><kbd>M</kbd></td>
                                                <td>Toggle music</td>
                                            </tr>
                                            <tr>
                                                <td><kbd>Esc</kbd></td>
                                                <td>Cancel letter selection</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hint Modal -->
        <div class="modal fade" id="hintModal" tabindex="-1" aria-labelledby="hintModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header bg-warning">
                        <h5 class="modal-title" id="hintModalLabel">Word Puzzle Hint</h5>
                        <button aria-label="Close" class="btn-close m-0" data-bs-dismiss="modal" type="button"></button>
                    </div>
                    <div class="modal-body">
                        <p>Looking for: <strong id="hint-word"></strong></p>
                        <p>This word can be found in the <span id="hint-direction"></span> direction.</p>
                        <p>Start looking around row <span id="hint-row"></span>, column <span id="hint-col"></span>.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>


<style>
    .puzzle-container {
        min-height: 400px;
    }
    
    .puzzle-grid-container {
        overflow-x: auto;
        border: 5px solid #dee2e6;
        border-radius: 8px;
        background-color: #ffffff;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .puzzle-grid {
        display: grid;
        grid-template-columns: repeat(15, 40px);
        grid-template-rows: repeat(15, 40px);
        gap: 5px;
        margin: 15px auto;
        user-select: none;
    }
    
    .puzzle-cell {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        font-weight: bold;
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .puzzle-cell:hover {
        background-color: #e9ecef;
        transform: scale(1.05);
        z-index: 2;
    }
    
    .puzzle-cell.selected {
        background-color: #b8daff;
        color: #000;
    }
    
    .puzzle-cell.highlighted {
        background-color: #28a745;
        color: white;
        animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    
    .word-list-container {
        max-height: 500px;
    }
    
    .word-list {
        max-height: 300px;
        overflow-y: auto;
    }
    
    .word-list-item {
        padding: 8px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #e9ecef;
        transition: all 0.3s ease;
    }
    
    .word-found {
        text-decoration: line-through;
        color: #28a745;
        background-color: #d4edda;
    }
    
    .word-found .word-found-indicator i {
        color: #28a745;
    }
    
    .word-found-indicator i {
        transition: all 0.3s ease;
    }
    
    .celebration-animation {
        animation: bounce 1s ease infinite;
    }
    
    @keyframes bounce {
        0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
        40% {transform: translateY(-30px);}
        60% {transform: translateY(-15px);}
    }
    
    .keyboard-shortcut-badge {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        cursor: pointer;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    /* Draggable selection styles */
    .selection-area {
        position: absolute;
        background-color: rgba(0, 123, 255, 0.3);
        border: 2px dashed #007bff;
        z-index: 10;
    }
    
    /* Confetti animation for completion */
    .confetti {
        position: fixed;
        width: 10px;
        height: 10px;
        background-color: #f2d74e;
        border-radius: 0;
        top: -10px;
        z-index: 9999;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .puzzle-grid {
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
        }
        
        .puzzle-cell {
            font-size: 14px;
        }
    }
    
    @media (max-width: 576px) {
        .puzzle-grid {
            grid-template-columns: repeat(15, 25px);
            grid-template-rows: repeat(15, 25px);
        }
        
        .puzzle-cell {
            font-size: 12px;
        }
    }
</style>

@endsection


@section('script')

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // Toast notifications
            @if(session('success'))
                setTimeout(() => {
                    Swal.fire({
                        icon: 'success',
                        title: "{{ session('success') }}",
                        toast: true,
                        position: 'top-end',
                        showConfirmButton: false,
                        timer: 2000,
                        timerProgressBar: true,
                        width: 'auto',
                    });
                }, 100);
            @endif
        
            @if(session('error'))
                setTimeout(() => {
                    Swal.fire({
                        icon: 'error',
                        title: "{{ session('error') }}",
                        toast: true,
                        position: 'top-end',
                        showConfirmButton: false,
                        timer: 2000,
                        timerProgressBar: true,
                        width: 'auto',
                    });
                }, 100);
            @endif

            // Add keyboard shortcut badge to page
            const shortcutBadge = document.createElement('div');
            shortcutBadge.className = 'keyboard-shortcut-badge';
            shortcutBadge.innerHTML = '<i class="ti ti-keyboard"></i>';
            shortcutBadge.addEventListener('click', function() {
                const shortcutModal = new bootstrap.Modal(document.getElementById('keyboardShortcutModal'));
                shortcutModal.show();
            });
            document.body.appendChild(shortcutBadge);

            // Initialize timer
            let totalSeconds = 0;
            let timerInterval;
            const minutesDisplay = document.getElementById('minutes');
            const secondsDisplay = document.getElementById('seconds');
            
            function startTimer() {
                timerInterval = setInterval(function() {
                    totalSeconds++;
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    
                    minutesDisplay.textContent = minutes < 10 ? '0' + minutes : minutes;
                    secondsDisplay.textContent = seconds < 10 ? '0' + seconds : seconds;
                }, 1000);
            }
            
            function stopTimer() {
                clearInterval(timerInterval);
            }
            
            // Background music control
            const musicToggleBtn = document.getElementById('toggle-music');
            const musicText = document.getElementById('music-text');
            const backgroundMusic = document.getElementById('background-music');
            
            musicToggleBtn.addEventListener('click', function() {
                if (backgroundMusic.paused) {
                    backgroundMusic.volume = 0.5; // Set volume to 50%
                    backgroundMusic.play();
                    musicText.textContent = 'Pause Music';
                    musicToggleBtn.classList.remove('btn-outline-secondary');
                    musicToggleBtn.classList.add('btn-outline-success');
                } else {
                    backgroundMusic.pause();
                    musicText.textContent = 'Play Music';
                    musicToggleBtn.classList.remove('btn-outline-success');
                    musicToggleBtn.classList.add('btn-outline-secondary');
                }
            });
            
            // Word Search Puzzle Generation
            const words = @json($words ?? []);
            const gridSize = 15; // 15x15 grid
            let grid = [];
            let wordLocations = [];
            let selectedCells = [];
            let foundWords = [];
            let isSelecting = false;
            let startCell = null; // Track initial selection point
            let dx = 0, dy = 0; // Direction vector

            // Flashcard navigation and progress tracking
            const totalWords = {{ count($words ?? []) }};
            const progressBar = document.getElementById('wsp-progress-bar');
            const currentWordDisplay = document.getElementById('current-word');
            // let totalWordsFound = foundWords.length;
            
            function updateProgress(totalWordsFound) {
                const progress = ((totalWordsFound) / totalWords) * 100;
                progressBar.style.width = progress + '%';
                currentWordDisplay.textContent = totalWordsFound;
            }
            
            // Generate the initial grid filled with empty spaces
            function initializeGrid() {
                grid = [];
                for (let i = 0; i < gridSize; i++) {
                    let row = [];
                    for (let j = 0; j < gridSize; j++) {
                        row.push('');
                    }
                    grid.push(row);
                }
            }
            
            // Directions for word placement
            const directions = [
                [0, 1],   // Horizontal right
                [1, 0],   // Vertical down
                [1, 1],   // Diagonal down-right
                [-1, 1],  // Diagonal up-right
                [0, -1],  // Horizontal left
                [-1, 0],  // Vertical up
                [-1, -1], // Diagonal up-left
                [1, -1]   // Diagonal down-left
            ];
            
            const directionNames = [
                "horizontal (right)",
                "vertical (down)",
                "diagonal (down-right)",
                "diagonal (up-right)",
                "horizontal (left)",
                "vertical (up)",
                "diagonal (up-left)",
                "diagonal (down-left)"
            ];
            
            // Check if a word can be placed at a position in a certain direction
            function canPlaceWord(word, row, col, dirRow, dirCol) {
                word = word.toUpperCase();
                const wordLength = word.length;
                
                // Check if word fits in grid boundaries
                if (
                    row + (wordLength - 1) * dirRow < 0 || 
                    row + (wordLength - 1) * dirRow >= gridSize ||
                    col + (wordLength - 1) * dirCol < 0 || 
                    col + (wordLength - 1) * dirCol >= gridSize
                ) {
                    return false;
                }
                
                // Check if word placement conflicts with existing letters
                for (let i = 0; i < wordLength; i++) {
                    const currentRow = row + i * dirRow;
                    const currentCol = col + i * dirCol;
                    
                    if (grid[currentRow][currentCol] !== '' && 
                        grid[currentRow][currentCol] !== word[i]) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Place a word on the grid
            function placeWord(word, row, col, dirRow, dirCol) {
                word = word.toUpperCase();
                const wordInfo = {
                    word: word,
                    start: { row, col },
                    end: { row: row + (word.length - 1) * dirRow, col: col + (word.length - 1) * dirCol },
                    direction: [dirRow, dirCol],
                    directionIndex: directions.findIndex(dir => dir[0] === dirRow && dir[1] === dirCol)
                };
                
                for (let i = 0; i < word.length; i++) {
                    const currentRow = row + i * dirRow;
                    const currentCol = col + i * dirCol;
                    grid[currentRow][currentCol] = word[i];
                }
                
                wordLocations.push(wordInfo);
            }
            
            // Try to place all words on the grid
            function placeWords() {
                wordLocations = [];
                
                for (const word of words) {
                    let placed = false;
                    let attempts = 0;
                    const maxAttempts = 100;
                    
                    while (!placed && attempts < maxAttempts) {
                        const direction = directions[Math.floor(Math.random() * directions.length)];
                        const row = Math.floor(Math.random() * gridSize);
                        const col = Math.floor(Math.random() * gridSize);
                        
                        if (canPlaceWord(word, row, col, direction[0], direction[1])) {
                            placeWord(word, row, col, direction[0], direction[1]);
                            placed = true;
                        }
                        
                        attempts++;
                    }
                    
                    if (!placed) {
                        console.warn(`Could not place word: ${word}`);
                        // If word couldn't be placed, place it in horizontal direction anyway
                        for (let row = 0; row < gridSize && !placed; row++) {
                            for (let col = 0; col <= gridSize - word.length && !placed; col++) {
                                if (canPlaceWord(word, row, col, 0, 1)) {
                                    placeWord(word, row, col, 0, 1);
                                    placed = true;
                                }
                            }
                        }
                    }
                }
            }
            
            // Fill the empty cells with random letters
            function fillEmptyCells() {
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (grid[i][j] === '') {
                            grid[i][j] = letters.charAt(Math.floor(Math.random() * letters.length));
                        }
                    }
                }
            }
            
            // Render the grid on the page
            function renderGrid() {
                const puzzleGrid = document.getElementById('puzzle-grid');
                puzzleGrid.innerHTML = '';
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'puzzle-cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.textContent = grid[i][j];
                        
                        // Cell selection events
                        cell.addEventListener('mousedown', startSelection);
                        cell.addEventListener('mouseover', continueSelection);
                        cell.addEventListener('mouseup', endSelection);
                        cell.addEventListener('touchstart', handleTouchStart);
                        cell.addEventListener('touchmove', handleTouchMove);
                        cell.addEventListener('touchend', handleTouchEnd);
                        
                        puzzleGrid.appendChild(cell);
                    }
                }
                
                // Add document-wide event listeners
                document.addEventListener('mouseup', () => {
                    if (isSelecting) {
                        isSelecting = false;
                        checkSelectedWord();
                    }
                });
            }
            
            // Generate the puzzle
            function generatePuzzle() {
                initializeGrid();
                placeWords();
                fillEmptyCells();
                renderGrid();
            }

            // Add a global variable to track the selection direction
            let selectionDirection = null;

            // Start the cell selection
            function startSelection(event) {
                isSelecting = true;
                selectedCells = [];
                selectionDirection = null; // Reset direction
                startCell = null;
                dx = dy = 0;
                clearSelection();
                
                const cell = event.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                startCell = { row, col };
                cell.classList.add('selected');
                selectedCells.push({ row, col });
                
                event.preventDefault();
            }

            // Continue the selection when moving mouse over cells
            function continueSelection(event) {
                if (!isSelecting) return;
                
                const cell = event.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // prevent invalid directions
                if (selectedCells.length === 1) {
                    dx = Math.sign(row - startCell.row);
                    dy = Math.sign(col - startCell.col);

                    // Only block diagonal if there's just 1 cell selected
                    if (dx !== 0 && dy !== 0) {
                        // If trying to start diagonal, require at least 2 cells
                        const nextRow = startCell.row + dx;
                        const nextCol = startCell.col + dy;
                        if (nextRow < 0 || nextRow >= gridSize || nextCol < 0 || nextCol >= gridSize) {
                            return; // Prevent diagonal if next cell is out of bounds
                        }
                    }
                } else {
                    const lastCell = selectedCells[selectedCells.length - 1];
                    // Check direction consistency using slope formula
                    const deltaRow = row - startCell.row;
                    const deltaCol = col - startCell.col;
                    
                    // For diagonal: require consistent slope of ±1
                    if (dx !== 0 && dy !== 0) {
                        if (Math.abs(deltaRow) !== Math.abs(deltaCol)) return;
                    }
                    
                    // For horizontal/vertical: require pure direction
                    if ((dx === 0 && deltaRow !== 0) || (dy === 0 && deltaCol !== 0)) return;
                }
                
                // Check if the cell is already selected
                const cellExists = selectedCells.some(c => c.row === row && c.col === col);
                if (cellExists) {
                    // Handle backtracking
                    const index = selectedCells.findIndex(c => c.row === row && c.col === col);
                    if (index !== -1) {
                        const cellsToRemove = selectedCells.slice(index + 1);
                        cellsToRemove.forEach(c => {
                            const cellElement = document.querySelector(`.puzzle-cell[data-row="${c.row}"][data-col="${c.col}"]`);
                            cellElement.classList.remove('selected');
                        });
                        selectedCells = selectedCells.slice(0, index + 1);
                    }
                    return;
                }
                
                if (selectedCells.length === 0) return;
                
                const lastCell = selectedCells[selectedCells.length - 1];
                const deltaRow = row - lastCell.row;
                const deltaCol = col - lastCell.col;
                
                // Calculate direction using Math.sign to handle positive/negative
                const dirRow = deltaRow !== 0 ? Math.sign(deltaRow) : 0;
                const dirCol = deltaCol !== 0 ? Math.sign(deltaCol) : 0;
                
                // Determine or check the selection direction
                if (selectedCells.length === 1) {
                    // Set the direction based on the second cell
                    selectionDirection = { dirRow, dirCol };
                } else {
                    // Check if the current direction matches the initial direction
                    if (dirRow !== selectionDirection.dirRow || dirCol !== selectionDirection.dirCol) {
                        return; // Direction changed, do not proceed
                    }
                }
                
                // Calculate steps needed to fill gaps
                const steps = Math.max(Math.abs(deltaRow), Math.abs(deltaCol));
                if (steps > 1) {
                    // Fill intermediate cells
                    for (let i = 1; i < steps; i++) {
                        const intermediateRow = lastCell.row + dirRow * i;
                        const intermediateCol = lastCell.col + dirCol * i;
                        
                        // Skip if already selected
                        if (!selectedCells.some(c => c.row === intermediateRow && c.col === intermediateCol)) {
                            const intermediateCell = document.querySelector(`.puzzle-cell[data-row="${intermediateRow}"][data-col="${intermediateCol}"]`);
                            if (intermediateCell) {
                                intermediateCell.classList.add('selected');
                                selectedCells.push({ row: intermediateRow, col: intermediateCol });
                            }
                        }
                    }
                }
                
                // Add the current cell to the selection
                cell.classList.add('selected');
                selectedCells.push({ row, col });
            }
            
            // End the selection
            function endSelection() {
                if (isSelecting) {
                    isSelecting = false;
                    checkSelectedWord();
                }
            }
            
            // Handle touch events for mobile devices
            function handleTouchStart(event) {
                event.preventDefault();
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (element && element.classList.contains('puzzle-cell')) {
                    startSelection({ target: element, preventDefault: () => {} });
                }
            }
            
            function handleTouchMove(event) {
                event.preventDefault();
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (element && element.classList.contains('puzzle-cell')) {
                    continueSelection({ target: element });
                }
            }
            
            function handleTouchEnd(event) {
                endSelection();
            }
            
            // Check if the selected word is in our word list
            function checkSelectedWord() {
                if (selectedCells.length < 2) {
                    clearSelection();
                    return;
                }
                
                let selectedWord = '';
                
                for (const cell of selectedCells) {
                    selectedWord += grid[cell.row][cell.col];
                }
                
                // Check both forward and backward
                const forwardWord = selectedWord;
                const backwardWord = selectedWord.split('').reverse().join('');
                
                const wordListItems = document.querySelectorAll('.word-list li');
                let matchFound = false;
                
                wordListItems.forEach(item => {
                    const word = item.dataset.word;
                    
                    if ((word === forwardWord || word === backwardWord) && !foundWords.includes(word)) {
                        matchFound = true;
                        foundWords.push(word);
                        
                        // Highlight the found word
                        item.classList.add('word-found');
                        const indicator = item.querySelector('.word-found-indicator');
                        indicator.innerHTML = '<i class="ti ti-check text-success"></i>';
                        
                        // Highlight the cells permanently
                        selectedCells.forEach(cell => {
                            const cellElement = document.querySelector(`.puzzle-cell[data-row="${cell.row}"][data-col="${cell.col}"]`);
                            cellElement.classList.remove('selected');
                            cellElement.classList.add('highlighted');
                        });
                        
                        // Update the found count
                        document.getElementById('found-count').textContent = foundWords.length;
                        updateProgress(foundWords.length);
                        
                        // Play a success sound
                        playSound('success');
                        
                        // Check if all words are found
                        if (foundWords.length === words.length) {
                            stopTimer();
                            showCompletionModal();
                        }
                        
                        return;
                    }
                });
                
                if (!matchFound) {
                    // Play an error sound if no match
                    playSound('error');
                    clearSelection();
                }
            }
            
            // Clear current selection
            function clearSelection() {
                document.querySelectorAll('.puzzle-cell.selected').forEach(cell => {
                    cell.classList.remove('selected');
                });
                selectedCells = [];
            }
            
            // Play sound effects
            function playSound(type) {
                const sound = new Audio();
                
                if (type === 'success') {
                    sound.src = "{{ asset('assets/audio/success.mp3') }}";
                } else if (type === 'error') {
                    sound.src = "{{ asset('assets/audio/error.mp3') }}";
                } else if (type === 'complete') {
                    sound.src = "{{ asset('assets/audio/success_2.mp3') }}";
                }
                
                sound.volume = 0.5;
                sound.play();
            }
            
            // Show the completion modal
            function showCompletionModal() {
                // Calculate score based on time
                const score = calculateScore();
                
                // Update modal content
                document.getElementById('time-taken').textContent = formatTime(totalSeconds);
                document.getElementById('final-score').textContent = score;
                
                // Play celebration sound
                playSound('complete');
                
                // Show confetti animation
                createConfetti();
                
                // Show the modal
                const resultModal = new bootstrap.Modal(document.getElementById('puzzleResultModal'));
                resultModal.show();
            }
            
            // Format seconds into MM:SS
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes < 10 ? '0' + minutes : minutes}:${remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds}`;
            }
            
            // Calculate score based on completion time
            function calculateScore() {
                // Base score
                const baseScore = 1000;
                
                // Time penalty (lose points the longer it takes)
                // The formula creates a decay curve - faster completion means higher score
                // For a 15x15 grid with ~10 words, a good completion time is around 2-3 minutes
                const optimalTime = 120; // 2 minutes is considered great
                const timeRatio = Math.max(0, 1 - (totalSeconds / (optimalTime * 2.5)));
                
                // Bonus for very fast completion
                let bonus = 0;
                if (totalSeconds < optimalTime) {
                    bonus = 300 * (1 - (totalSeconds / optimalTime));
                }
                
                // Final score calculation (with minimum score of 100)
                const finalScore = Math.max(100, Math.round(baseScore * timeRatio + bonus));
                
                return finalScore;
            }
            
            // Create confetti animation
            function createConfetti() {
                const confettiCount = 200;
                const colors = ['#f2d74e', '#95c3de', '#ff9a91', '#f2b2e2', '#aaf683'];
                
                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti animate__animated animate__fadeOutUp';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    document.body.appendChild(confetti);
                    
                    // Remove confetti after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, 5000);
                }
            }
            
            // Give Up button functionality
            document.getElementById('give-up').addEventListener('click', function() {
                Swal.fire({
                    title: 'Are you sure?',
                    text: "You're about to reveal all the hidden words!",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#d33',
                    cancelButtonColor: '#3085d6',
                    confirmButtonText: 'Yes, show me the solution'
                }).then((result) => {
                    if (result.isConfirmed) {
                        revealSolution();
                    }
                });
            });
            
            // Reveal the solution
            function revealSolution() {
                // Clear any current selections
                clearSelection();
                
                // Stop the timer
                stopTimer();
                
                // Highlight all word locations
                wordLocations.forEach(wordInfo => {
                    // Highlight the cells for this word
                    const dirRow = wordInfo.direction[0];
                    const dirCol = wordInfo.direction[1];
                    const wordLength = wordInfo.word.length;
                    
                    for (let i = 0; i < wordLength; i++) {
                        const currentRow = wordInfo.start.row + i * dirRow;
                        const currentCol = wordInfo.start.col + i * dirCol;
                        
                        const cellElement = document.querySelector(`.puzzle-cell[data-row="${currentRow}"][data-col="${currentCol}"]`);
                        cellElement.classList.add('highlighted');
                    }
                    
                    // Mark the word as found in the list
                    const wordListItem = document.querySelector(`.word-list li[data-word="${wordInfo.word}"]`);
                    if (wordListItem && !wordListItem.classList.contains('word-found')) {
                        wordListItem.classList.add('word-found');
                        const indicator = wordListItem.querySelector('.word-found-indicator');
                        indicator.innerHTML = '<i class="ti ti-check text-success"></i>';
                    }
                });
                
                // Update found count
                document.getElementById('found-count').textContent = words.length;
                
                // Show a message
                Swal.fire({
                    title: 'Solution Revealed',
                    text: 'All words have been highlighted on the grid.',
                    icon: 'info',
                    confirmButtonText: 'OK'
                });
            }
            
            // Show hint functionality
            document.getElementById('show-hint').addEventListener('click', function() {
                showRandomHint();
            });
            
            // Show a random hint for an unfound word
            function showRandomHint() {
                // Get unfound words
                const unfoundWords = words.filter(word => !foundWords.includes(word.toUpperCase()));
                
                if (unfoundWords.length === 0) {
                    Swal.fire({
                        title: 'No More Hints',
                        text: 'You\'ve found all the words already!',
                        icon: 'success',
                        confirmButtonText: 'OK'
                    });
                    return;
                }
                
                // Select a random unfound word
                const randomWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];
                
                // Find its location info
                const wordInfo = wordLocations.find(info => info.word === randomWord.toUpperCase());
                
                if (!wordInfo) {
                    console.error('Word location info not found for:', randomWord);
                    return;
                }
                
                // Update hint modal
                document.getElementById('hint-word').textContent = randomWord;
                document.getElementById('hint-direction').textContent = directionNames[wordInfo.directionIndex];
                document.getElementById('hint-row').textContent = (wordInfo.start.row + 1);
                document.getElementById('hint-col').textContent = (wordInfo.start.col + 1);
                
                // Show the hint modal
                const hintModal = new bootstrap.Modal(document.getElementById('hintModal'));
                hintModal.show();
            }
            
            // Restart puzzle button
            document.getElementById('restart-puzzle').addEventListener('click', function() {
                location.reload();
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(event) {
                // ESC key to cancel selection
                if (event.key === 'Escape') {
                    clearSelection();
                }
                
                // H key for hint
                if (event.key === 'h' || event.key === 'H') {
                    showRandomHint();
                }
                
                // M key to toggle music
                if (event.key === 'm' || event.key === 'M') {
                    musicToggleBtn.click();
                }
            });
            
            // Initialize the puzzle
            generatePuzzle();
            startTimer();
        });
    </script>
@endsection